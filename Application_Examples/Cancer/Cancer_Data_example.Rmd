---
title: "Cancer Data"
author: "Yao Song"
date: "6/26/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(dplyr)
# install.packages("corpcor")
library(corpcor)
library(mctest)
library(ppcor)
library(Hmisc)
```


# 1. Data Preprocessing 

About PSA:

In general, a PSA level that is above 4.0 ng/mL is considered suspicious. However, there are many other factors to consider before taking further action. The following are some general guidelines to help you understand your PSA test results:

* 0 to 2.5 ng/mL is considered safe
* 2.6 to 4 ng/mL is safe in most men but talk with your doctor about other risk factors
* 4.0 to 10.0 ng/mL is suspicious and might suggest the possibility of prostate cancer. It is associated with a 25% chance of having prostate cancer.
* 10.0 ng/mL and above is dangerous and should be discussed with your doctor immediately. It is associated with a 50% chance of having prostate cancer.
However, PSA levels can easily rise with greater age. You and your physician should consult age-specific normal PSA ranges.


```{r}
CancerData <- read_csv("data to pass.csv")
cate_col = which(unlist(lapply(matrix(CancerData), is.character)))## select columns numbers of categorical variable 
cate_col = c(cate_col[-c(30:33)], 32)            # not sure about how to deal with the PSA data (many missing and na's)

CancerData.fac = CancerData
CancerData.fac$`Resp (Meas)`[which(CancerData.fac$`Resp (Meas)` == "n/a")] = NA
CancerData.fac[cate_col] = lapply(CancerData.fac[cate_col], as.factor)  ## as.factor() could also be used
levels(CancerData.fac$Strat) = c("High", "Low")
levels(CancerData.fac$C1) = c("Failure", "Success")
levels(CancerData.fac$C2) = levels(CancerData.fac$C3) = levels(CancerData.fac$C4) = c("--", "Failure", "Success")
levels(CancerData.fac$`Ever TEC`) = levels(CancerData.fac$`Ever KA/VE`) = levels(CancerData.fac$`Ever TEE`) = levels(CancerData.fac$`Ever CVD`) = levels(CancerData.fac$`Drop Related to outcome`) = c("No", "Yes")
summary(CancerData.fac)


baseline_cov.names = c("Age at Reg", #"Def Loc Rx?", 
                       "LocRx at Dx", "Time, Horm Rx to Reg (mo)", 
                       "EOD at Entry", 
                       # "Strat", 
                       "Bsln PSA", "Alk Phos", "Hgb")
trt1.name = "Rx, Course 1"
trt2.name = "Rx, Course 2"
Surv_time.name = "Surv from Horm Rx (yrs)"   # Not sure. "Surv from Reg (mo)" ?
Toxicity1.name = "C1X1"      # In, NS, S, SPD
Efficacy1.name = "C1X2"      # No ET, ET1, ET2
Toxicity2.name = "C2X1"      # --(23), In, NS, S, SPD
Efficacy2.name = "C2X2"      # --(23), No ET, ET1, ET2


CancerData.clean = CancerData.fac[,c(baseline_cov.names, trt1.name, trt2.name, 
                                     Toxicity1.name, Efficacy1.name, 
                                     Toxicity2.name, Efficacy2.name, Surv_time.name)]
# remove those who stop the regime at stage 2 for any reasons
CancerData.clean = CancerData.clean[which(!(CancerData.clean$`Rx, Course 2` %in% c("Died", "Off"))),]

CancerData.clean$`Rx, Course 2` = droplevels(CancerData.clean$`Rx, Course 2`)
CancerData.clean$C2X1 = droplevels(CancerData.clean$C2X1)
CancerData.clean$C2X2 = droplevels(CancerData.clean$C2X2)
summary(CancerData.clean)

CancerData.clean1 = CancerData.clean %>% 
  mutate(Treatment1 = case_when(`Rx, Course 1` == "CVD" ~ 1, 
                                `Rx, Course 1` == "KA/VE" ~ 2,
                                `Rx, Course 1` == "TEC" ~ 3,
                                TRUE ~ 4),
         Treatment2 = case_when(`Rx, Course 2` == "CVD" ~ 1, 
                                `Rx, Course 2` == "KA/VE" ~ 2,
                                `Rx, Course 2` == "TEC" ~ 3,
                                TRUE ~ 4),
         Eff1 = case_when(C1X1 == "In" ~ 0,
                          C1X1 == "SPD" ~ 1,
                          C1X1 == "S" ~ 2,
                          TRUE ~ 3), 
         Tox1 = case_when(C1X2 == "ET2" ~ 0, 
                          C1X2 == "ET1" ~ 1,
                          TRUE ~ 2), 
         Eff2 = case_when(C2X1 == "In" ~ 0,
                          C2X1 == "SPD" ~ 1,
                          C2X1 == "S" ~ 2,
                          TRUE ~ 3), 
         Tox2 = case_when(C2X2 == "ET2" ~ 0, 
                          C2X2 == "ET1" ~ 1,
                          TRUE ~ 2)) %>%
  mutate(Exp.score1 = case_when(Eff1 == 3 & Tox1 == 2  ~ 1, 
                                Eff1 == 2 & Tox1 == 2  ~ 0.5, 
                                Eff1 == 1 & Tox1 == 2  ~ 0.1,
                                Eff1 == 3 & Tox1 == 1  ~ 0.8, 
                                Eff1 == 2 & Tox1 == 1  ~ 0.3, 
                                Eff1 == 1 & Tox1 == 1  ~ 0, 
                                TRUE ~ 0), 
         Exp.score2 = case_when(Eff2 == 3 & Tox2 == 2  ~ 1, 
                                Eff2 == 2 & Tox2 == 2  ~ 0.5, 
                                Eff2 == 1 & Tox2 == 2  ~ 0.1,
                                Eff2 == 3 & Tox2 == 1  ~ 0.8, 
                                Eff2 == 2 & Tox2 == 1  ~ 0.3, 
                                Eff2 == 1 & Tox2 == 1  ~ 0,
                                TRUE ~ 0)) 
# CancerData.clean1 = CancerData.clean1[,-c(C1X1, C1X2)]

summary(CancerData.clean1)
```

# 2. Apllying MOTRL package

## Preperation
```{r}
# prepare for models
N = nrow(CancerData.clean1)
Cov = CancerData.clean1[,c(1:7)]
summary(Cov)

Ys2 = CancerData.clean1[, c("Surv from Horm Rx (yrs)", "Eff2", "Tox2")]
Ys2.2 = CancerData.clean1[, c("Surv from Horm Rx (yrs)", "Exp.score2")]

Trt2 = CancerData.clean1$Treatment2

Ys1 = CancerData.clean1[, c("Exp.score1")]
Trt1 = CancerData.clean1$Treatment1
```

Checking colinearity
```{r}
Cov.cor = Cov
levels(Cov.cor$`LocRx at Dx`) = c(1, 2, 0, 3, 4, 5)
levels(Cov.cor$`EOD at Entry`) = c(5, 3, 1, 2, 4)
Cov.cor$`LocRx at Dx` = as.numeric(Cov.cor$`LocRx at Dx`)
Cov.cor$`EOD at Entry` = as.numeric(Cov.cor$`EOD at Entry`)
Cov.cor = as.matrix(Cov.cor)
#create matrix of correlation coefficients and p-values
rcorr(Cov.cor)
cor2pcor(cor(Cov.cor))
pcor(Cov.cor, method = "pearson")
```

## Stage 2

**4 Treatment options: A $\in$ {1, 2, 3, 4}**
1: cyclophosphamide, vincristine, and dexamethasone (CVD);
2: ketoconazole plus doxorubicin alternating with vinblastine plus estramustine (KA/VE); 
3: paclitaxel, estramustine, and carboplatin (TEC); 
4: paclitaxel, estramustine, and etoposide (TEE). 

**3 Objectives**
* Maximizing survival time
* Maximizing efficacy
* Minimizing toxicity

**7 Tailoring variables**

```{r}
# Multi-objective Tolerant DTR tree
# Design a pre-specified 3-dim weight vector w
w2 = c(0.8, 0.1, 0.1)
w2 = c(0.6, 0.2, 0.2)
w2 = c(0.3, 0.4, 0.3)

# The most flexible case delta = 0 (allow all treatments) --> CVD is the optimal treatment at stage 2
tree2_MOtol0 = MO.tol.DTRtree(Ys = Ys2, w = w2, A = Trt2, H = cbind(Cov,Ys1,Trt1), 
                              delta = 0, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.02, minsplit = 5)
knitr::kable(tree2_MOtol0, digits = 2)

# When delta = 0.5 (allow some of the treatments)
tree2_MOtol0 = MO.tol.DTRtree(Ys = Ys2, w = w2, A = Trt2, H = cbind(Cov,Ys1,Trt1), 
                              delta = 0.4, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.02, minsplit = 5)
knitr::kable(tree2_MOtol0, digits = 2)

# The most strict case delta = 1 (allow only the optimal treatment)
tree2_MOtol1 = MO.tol.DTRtree(Ys = Ys2, w = w2, A = Trt2, H = cbind(Cov,Ys1), 
                              delta = 1, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.01, minsplit = 5)
knitr::kable(tree2_MOtol1, digits = 2)
```

(Another way: 2 Objectives)
* Maximizing survival time
* Maximizing expert score

```{r}
w2.2 = c(0.8, 0.2)
w2.2 = c(0.5, 0.5)
w2.2 = c(0.2, 0.8)

############### depth = 3, lambda.pct = 0.05, minsplit = 10
# The most flexible case delta = 0 (allow all treatments) --> CVD is the optimal treatment at stage 2
tree2_MOtol0 = MO.tol.DTRtree(Ys = Ys2.2, w = w2.2, A = Trt2, H = cbind(Cov,Ys1,Trt1), 
                              delta = 0, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.05, minsplit = 10)
knitr::kable(tree2_MOtol0$tree, digits = 2)

# When delta = 0.4 (allow some of the treatments)
tree2_MOtol0 = MO.tol.DTRtree(Ys = Ys2.2, w = w2.2, A = Trt2, H = cbind(Cov,Ys1,Trt1), 
                              delta = 0.3, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.05, minsplit = 10)
knitr::kable(tree2_MOtol0$tree, digits = 2)



################ depth = 2, lambda.pct = 0.02, minsplit = 5
# The most flexible case delta = 0 (allow all treatments) --> CVD is the optimal treatment at stage 2
tree2_MOtol0 = MO.tol.DTRtree(Ys = Ys2.2, w = w2.2, A = Trt2, H = cbind(Cov,Ys1,Trt1), 
                              delta = 0, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.02, minsplit = 5)
knitr::kable(tree2_MOtol0$tree, digits = 2)

# When delta = 0.4 (allow some of the treatments)
tree2_MOtol0 = MO.tol.DTRtree(Ys = Ys2.2, w = w2.2, A = Trt2, H = cbind(Cov,Ys1,Trt1), 
                              delta = 0.3, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.02, minsplit = 5)
knitr::kable(tree2_MOtol0$tree, digits = 2)
```


## Backward induction to stage 1
```{r}
w2.2 = c(0.8, 0.2)
w2.2 = c(0.5, 0.5)
w2.2 = c(0.4, 0.6)
w2.2 = c(0.2, 0.8)

tree2 = MO.tol.DTRtree(Ys = Ys2.2, w = w2.2, A = Trt2, H = cbind(Cov,Ys1,Trt1), 
                       delta = 0.3, tolerate = TRUE, m.method="AIPW", 
                       depth = 3, lambda.pct = 0.02, minsplit = 5)
knitr::kable(tree2$tree, digits = 2)

############### stage 1 Estimation #############################
# calculate average pseudo outcome (avePO)
# # estimated optimal regime for each patients
# opt.trt2 <- predict_DTR(tree2$tree, newdata = cbind(Cov,Ys1,Trt1))
# # estimated tolerant regime for each patients
# tol.trt2 <- predict_tol.DTR(tree2$tree, newdata = cbind(Cov,Ys1,Trt1))

# Accumulated PO
PO.loss2 = tree2$PO.loss 
PO1 <- Ys1 + PO.loss2

############################################
# tol.DTRtree

# tree1 <- DTRtree(PO.tree,A1,H=X0,pis.hat=pis1.hat,lambda.pct=0.02,minsplit=max(0.05*N,20))


tree1 = MO.tol.DTRtree(Ys = PO1, w = c(1), A = Trt1, H = Cov, 
                       delta = 0, tolerate = TRUE, m.method="AIPW", 
                       depth = 3, lambda.pct = 0.02, minsplit = 8)
knitr::kable(tree1$tree, digits = 2)


tree1 = MO.tol.DTRtree(Ys = PO1, w = c(1), A = Trt1, H = Cov, 
                       delta = 0.3, tolerate = TRUE, m.method="AIPW", 
                       depth = 3, lambda.pct = 0.02, minsplit = 8)
knitr::kable(tree1$tree, digits = 2)
```


