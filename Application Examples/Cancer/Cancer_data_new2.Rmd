---
title: "Cancer Data"
author: "Yao Song"
date: "7/2/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(dplyr)
# install.packages("corpcor")
library(corpcor)
library(mctest)
library(ppcor)
library(Hmisc)
library(scales)
library(table1)
library(rstatix)
```


# 1. Data Preprocessing 

Info About PSA:

In general, a PSA level that is above 4.0 ng/mL is considered suspicious. However, there are many other factors to consider before taking further action. The following are some general guidelines to help you understand your PSA test results:

* 0 to 2.5 ng/mL is considered safe
* 2.6 to 4 ng/mL is safe in most men but talk with your doctor about other risk factors
* 4.0 to 10.0 ng/mL is suspicious and might suggest the possibility of prostate cancer. It is associated with a 25% chance of having prostate cancer.
* 10.0 ng/mL and above is dangerous and should be discussed with your doctor immediately. It is associated with a 50% chance of having prostate cancer.
However, PSA levels can easily rise with greater age. You and your physician should consult age-specific normal PSA ranges.


```{r}
CancerData = read_csv("data to pass clean.csv")
CancerData.fac = CancerData



# covariates
baseline_cov.names = c("Age at Reg", 
                       "Def Loc Rx?",  # Ever local therapy
                       # "LocRx at Dx",
                       "Time, Horm Rx to Reg (mo)", # Time of Hormone therapy at registration 
                       # "EOD at Entry",
                       "Strat",  # Binary
                       "Bsln PSA", 
                       "Alk Phos", # 
                       "Hgb")
cov.names = "PSA1" #, "PSA2")
# Treatments
trt1.name = "Treatment 1"
trt2.name = "Treatment 2"
# Outcomes
Surv_time.name = "Surv from Reg (mo)" #?
Toxicity1.name = "T1"      # In, NS, S, SPD
Efficacy1.name = "E1"      # No ET, ET1, ET2
Toxicity2.name = "T2"      # In, NS, S, SPD  (NA's :75)
Efficacy2.name = "E2"      # No ET, ET1, ET2 (NA's :75)


CancerData.clean = CancerData.fac[,c(baseline_cov.names, cov.names, 
                                     trt1.name, trt2.name, 
                                     Toxicity1.name, Efficacy1.name, 
                                     Toxicity2.name, Efficacy2.name, Surv_time.name)]
# Using baseline psa to impute psa1 for row 132
# Using psa1 to impute psa2 for row 19
# CancerData.clean$PSA2[19] = 275
CancerData.clean$PSA1[132] = 72
CancerData.clean$PSA1[10] = 25
# remove those who have ET or PD and off the regime 
# 15, 24, 35, 59, 67?, 69, 95 row in the raw data
# 11? has all PSA values missing, also drop??
CancerData.clean = CancerData.clean[-(c(15, 24, 35, 59, 69, 95)-1),]
CancerData.clean$PSA1 = as.numeric(CancerData.clean$PSA1)
# CancerData.clean$PSA2 = as.numeric(CancerData.clean$PSA2)
summary(CancerData.clean)

CancerData.clean1 = CancerData.clean %>% 
  mutate(Treatment1 = case_when(`Treatment 1` == "CVD" ~ 1, 
                                `Treatment 1` == "KA/VE" ~ 2,
                                `Treatment 1` == "TEC" ~ 3,
                                TRUE ~ 4),
         Treatment2 = case_when(`Treatment 2` == "CVD" ~ 1, 
                                `Treatment 2` == "KA/VE" ~ 2,
                                `Treatment 2` == "TEC" ~ 3,
                                `Treatment 2` == "TEE" ~ 4),
         Exp.score1 = case_when(E1 == "S" & T1 == "No ET"  ~ 1, 
                                E1 == "S" & T1 == "ET1"  ~ 0.8, 
                                E1 == "NS" & T1 == "No ET"  ~ 0.5, 
                                E1 == "NS" & T1 == "ET1"  ~ 0.3, 
                                E1 == "SPD" & T1 == "No ET"  ~ 0.1, 
                                E1 == "SPD" & T1 == "ET1"  ~ 0, 
                                TRUE ~ 0), 
         Exp.score2 = case_when(E2 == "S" & T2 == "No ET"  ~ 1, 
                                E2 == "S" & T2 == "ET1"  ~ 0.8, 
                                E2 == "NS" & T2 == "No ET"  ~ 0.5, 
                                E2 == "NS" & T2 == "ET1"  ~ 0.3, 
                                E2 == "SPD" & T2 == "No ET"  ~ 0.1, 
                                E2 == "SPD" & T2 == "ET1"  ~ 0,
                                E2 == "In" & T2 == "ET2"  ~ 0))


# Addition
# CancerData.clean1$Treatment1 = as.character(CancerData.clean1$Treatment1)
# CancerData.clean1$Treatment2 = as.character(CancerData.clean1$Treatment2)
# CancerData.clean1$Treatment1 = as.factor(CancerData.clean1$Treatment1)
# CancerData.clean1$Treatment2 = as.factor(CancerData.clean1$Treatment2)


CancerData.clean1$SurTime.scaled = rescale(CancerData.clean1$`Surv from Reg (mo)`)
# CancerData.clean1 = CancerData.clean1[,-c(C1X1, C1X2)]
CancerData.clean1 = cbind(1:nrow(CancerData.clean1), CancerData.clean1)
names(CancerData.clean1)[1] = "ID"
summary(CancerData.clean1)
```

```{r}
CancerData.clean2 = CancerData.clean1[complete.cases(CancerData.clean1),]
```


# Table A1. Patient Characteristics
```{r}
# New Method
my.render.cont <- function(x) {
    with(stats.apply.rounding(stats.default(x), digits=2), c("",
        "Mean (SD)"=sprintf("%s (&plusmn; %s)", MEAN, SD)))
}

my.render.cat <- function(x) {
    c("", sapply(stats.default(x), function(y) with(y,
        sprintf("%d (%0.0f %%)", FREQ, PCT))))
}
pvalue <- function(x, ...) {
    # Construct vectors of data y, and groups (strata) g
    y <- unlist(x)
    g <- factor(rep(1:length(x), times=sapply(x, length)))
    if (is.numeric(y)) {
        # For numeric variables, perform a standard 2-sample t-test
        # p <- t.test(y ~ g)$p.value
        p <- anova_summary(Anova(y ~ g))$p

    } else {
        # For categorical variables, perform a chi-squared test of independence
        p <- chisq.test(table(y, g))$p.value
    }
    # Format the p-value, using an HTML entity for the less-than sign.
    # The initial empty string places the output on the line below the variable label.
    c("", sub("<", "&lt;", format.pval(p, digits=3, eps=0.001)))
}

# Generate table 1
CancerData.table1 = CancerData.clean1
CancerData.table1$Strat = as.factor(CancerData.table1$Strat)
levels(CancerData.table1$Strat) <- c("High", "Low")
strata = c(split(CancerData.table1, CancerData.table1$`Treatment 1`), list(Total = CancerData.table1))
labels <- list(
    variables=list(`Age at Reg` = "Age (years)" ,
                   `Def Loc Rx?`= "History of ???",
                   `Time, Horm Rx to Reg (mo)` = "Time of horm??? before registration",
                   Strat = "Disease Volume",
                   `Alk Phos` = "Alk Phos ???",
                   Hgb = "Hgb???",
                   `Bsln PSA` = "PSA at Baseline (ng/mL)", 
                   PSA1 = "PSA after first chemo (ng/mL)",
                   # `Treatment 1` = "First chemotherapy",
                   `Treatment 2` = "Second chemotherapy",
                   `Exp.score1` = "Expert score after first chemotherapy",
                   `Exp.score2` = "Expert score after second chemotherapy",
                   `Surv from Reg (mo)` = "Survival time after registration (mo)"),
    groups=list("First chemotherapy", "")
    )

levels(CancerData.table1$`Treatment 1`) <- c("CVD", "KA/VE", "TEC", "TEE")

table1(strata, labels, groupspan = c(4, 1)
       , render.continuous = my.render.cont, render.categorical = my.render.cat)
```



# 2. Apllying MOTRL package

## Preperation for modeling
```{r}
# Stage 2
N2 = nrow(CancerData.clean2)
colnames(CancerData.clean2)
Cov2 = CancerData.clean2[,c(1:4,6:8,9) + 1]# 17)] # all baseline and PSA2, Treatment 1 # AND Outcome1
summary(Cov2)
Ys2 = CancerData.clean2[, c("SurTime.scaled", "Exp.score2")]
Trt2 = CancerData.clean2$`Treatment 2`
Outcomes1 = CancerData.clean2[, c("SurTime.scaled", "Exp.score1")]
ES1 = CancerData.clean2$Exp.score1

# Stage 1
N1 = nrow(CancerData.clean1)
Cov1 = CancerData.clean1[,c(1:7)+1] # all baseline and Bsln PSA
summary(Cov1)
Ys1 = CancerData.clean1[, c("SurTime.scaled", "Exp.score1")]
Trt1 = CancerData.clean1$`Treatment 1`
```

## Stage 2

**4 Treatment options: A $\in$ {1, 2, 3, 4}**
1: cyclophosphamide, vincristine, and dexamethasone (CVD);
2: ketoconazole plus doxorubicin alternating with vinblastine plus estramustine (KA/VE); 
3: paclitaxel, estramustine, and carboplatin (TEC); 
4: paclitaxel, estramustine, and etoposide (TEE). 

**2 Objectives**
* Maximizing survival time
* Maximizing expert score

**7 Tailoring variables**

survival time
```{r}
# Multi-objective Tolerant DTR tree
# Design a pre-specified 3-dim weight vector w
############### depth = 3, lambda.pct = 0.05, minsplit = 10
# w2.1
w2.1 = c(1, 0) # more weight on survival time
Y1.1 = tcrossprod(as.matrix(Outcomes1), t(w2.1))
# The most flexible case delta = 0 (allow all treatments) --> KA/VE is the optimal treatment at stage 2
tree2_MOtol1.0 = MO.tol.DTRtree(Ys = Ys2, w = w2.1, A = Trt2, H = cbind(Cov2),
                              delta = 0, tolerate = TRUE, m.method="AIPW", 
                              depth = 1, lambda.pct = 0.02, minsplit = 15)
knitr::kable(tree2_MOtol1.0$tree, digits = 2)
# When delta = 0.4 (allow some of the treatments) --> KA/VE is the only tplerant treatment at stage 2
tree2_MOtol1.4 = MO.tol.DTRtree(Ys = Ys2, w = w2.1, A = Trt2, H = cbind(Cov2),
                              delta = 0.3, tolerate = TRUE, m.method="AIPW", 
                              depth = 1, lambda.pct = 0.02, minsplit = 15)
knitr::kable(tree2_MOtol1.4$tree, digits = 2)
```

equal weights
```{r}
# w2.2
w2.2 = c(0.5, 0.5)
Y1.2 = tcrossprod(as.matrix(Outcomes1), t(w2.2))
# The most flexible case delta = 0 (allow all treatments) --> KA/VE is the optimal treatment at stage 2
tree2_MOtol2.0 = MO.tol.DTRtree(Ys = Ys2, w = w2.2, A = Trt2, H = cbind(Cov2),
                              delta = 0, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.02, minsplit = 10)
knitr::kable(tree2_MOtol2.0$tree, digits = 2)
# When delta = 0.4 (allow some of the treatments) -->  KA/VE and CVD is the tolerant treatment at stage 2
tree2_MOtol2.4 = MO.tol.DTRtree(Ys = Ys2, w = w2.2, A = Trt2, H = cbind(Cov2),
                              delta = 0.3, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.02, minsplit = 10)
knitr::kable(tree2_MOtol2.4$tree, digits = 2)
```

expert score
```{r}
# w2.3
w2.3 = c(0, 1) # more weight on effect right after treatment (expert score)
Y1.3 = tcrossprod(as.matrix(Outcomes1), t(w2.3))
# The most flexible case delta = 0 (allow all treatments) --> CVD is the optimal treatment at stage 2
tree2_MOtol3.0 = MO.tol.DTRtree(Ys = Ys2, w = w2.3, A = Trt2, H = cbind(Cov2),
                              delta = 0, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.01, minsplit = 15)
knitr::kable(tree2_MOtol3.0$tree, digits = 2)
# When delta = 0.4 (allow some of the treatments) -->  KA/VE and CVD is the tolerant treatment at stage 2
tree2_MOtol3.4 = MO.tol.DTRtree(Ys = Ys2, w = w2.3, A = Trt2, H = cbind(Cov2),
                              delta = 0.4, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.01, minsplit = 15)
knitr::kable(tree2_MOtol3.4$tree, digits = 2)
```
Comments:

* When we add more weight on the long-term effect (Survival time) of the chemotherapy on patients, KA/VE is the optimal stage 2 treatment.

* When we add more weight on the immediate effect of the chemotherapy on patients, CVD is the optimal stage 2 treatment.

* When put equal weights (1:1) and other weights in-between 1:4 and 4:1 on the two objectives, and define tolerant rate as 60%, both KA/VE and CVD are tolerant regimes.




## Backward induction to stage 1

1. If apply equal weight on the two objectives

```{r}
# here we use the second tolerant tree w = (0.5, 0.5)
# tree2 = MO.tol.DTRtree(Ys = Ys2, w = w2.2, A = Trt2, H = cbind(Cov2,Y1.2),
#                               delta = 0.2, tolerate = TRUE, m.method="AIPW", 
#                               depth = 3, lambda.pct = 0.05, minsplit = 15)
tree2 = tree2_MOtol2.4
treeout2 = tree2$tree
knitr::kable(treeout2, digits = 2)
############### stage 1 Estimation #############################
# calculate average pseudo outcome (avePO)
# # estimated optimal regime for each patients
# opt.trt2 <- predict_DTR(tree2$tree, newdata = cbind(Cov,Ys1,Trt1))
# # estimated tolerant regime for each patients
tol.trt2 <- predict_tol.DTR(treeout2, newdata = cbind(Cov2))
# Accumulated PO
PO.loss2 = tree2$PO.loss 
# PO1 <- Ys1 + PO.loss2 # I have wrote this into the function MO.tol.DTRtree
PO.loss.comp = matrix(0, nrow = 144, ncol = 2)
PO.loss.comp[CancerData.clean2[,1],] = PO.loss2

# Stage 1 tree
# w1.2
w1.2 = c(0.5, 0.5)
# The most flexible case delta = 0 (allow all treatments) --> KA/VE is the optimal treatment at stage 2
tree1_MOtol2.0 = MO.tol.DTRtree(Ys = Ys1, w = w1.2, A = Trt1, H = Cov1,
                              delta = 0, tolerate = TRUE, m.method="AIPW", 
                              depth = 2, lambda.pct = 0.02, minsplit = 20,
                              PO.loss = PO.loss.comp)
knitr::kable(tree1_MOtol2.0$tree, digits = 2)
# When delta = 0.4 (allow some of the treatments) -->  KA/VE and CVD is the tolerant treatment at stage 2
tree1_MOtol2.4 = MO.tol.DTRtree(Ys = Ys1, w = w1.2, A = Trt1, H = Cov1,
                              delta = 0.3, tolerate = TRUE, m.method="AIPW", 
                              depth = 2, lambda.pct = 0.02, minsplit = 20, 
                              PO.loss = PO.loss.comp)
knitr::kable(tree1_MOtol2.4$tree, digits = 2)
```


2. Similarly, if use the first tree2 (only care about survival)

We can see from the outcome tree1 that when only care about survival time, patients that have Hgb value < 12.9 (nearly half of the patients) are recommended to take CVD  as their first treatment.

```{r}
tree2 = tree2_MOtol1.4
treeout2 = tree2$tree
knitr::kable(treeout2, digits = 2)
############### stage 1 Estimation #############################
tol.trt2 <- predict_tol.DTR(treeout2, newdata = cbind(Cov2))
# Accumulated PO
PO.loss2 = tree2$PO.loss 
# PO1 <- Ys1 + PO.loss2 # I have wrote this into the function MO.tol.DTRtree
PO.loss.comp = matrix(0, nrow = 144, ncol = 2)
PO.loss.comp[CancerData.clean2[,1],] = PO.loss2
# w1.2
w1.1 = c(1, 0)
# The most flexible case delta = 0 (allow all treatments) --> KA/VE is the optimal treatment at stage 2
tree1_MOtol1.0 = MO.tol.DTRtree(Ys = Ys1, w = w1.1, A = Trt1, H = Cov1,
                              delta = 0, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.05, minsplit = 20,
                              PO.loss = PO.loss.comp)
knitr::kable(tree1_MOtol1.0$tree, digits = 2)
# When delta = 0.4 (allow some of the treatments) -->  KA/VE and CVD is the tolerant treatment at stage 2
tree1_MOtol1.4 = MO.tol.DTRtree(Ys = Ys1, w = w1.1, A = Trt1, H = Cov1,
                              delta = 0.3, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.05, minsplit = 20, 
                              PO.loss = PO.loss.comp)
knitr::kable(tree1_MOtol1.4$tree, digits = 2)
```

3. Similarly, if use the third tree2 (only care about expert score)

Great! We can see from this tree1 that when only care about expert score, 

```{r}
tree2 = tree2_MOtol3.4
treeout2 = tree2$tree
knitr::kable(treeout2, digits = 2)
############### stage 1 Estimation #############################
tol.trt2 <- predict_tol.DTR(treeout2, newdata = cbind(Cov2))
# Accumulated PO
PO.loss2 = tree2$PO.loss 
# PO1 <- Ys1 + PO.loss2 # I have wrote this into the function MO.tol.DTRtree
PO.loss.comp = matrix(0, nrow = 144, ncol = 2)
PO.loss.comp[CancerData.clean2[,1],] = PO.loss2
# w1.2
w1.3 = c(0, 1)
# The most flexible case delta = 0 (allow all treatments) --> KA/VE is the optimal treatment at stage 2
tree1_MOtol3.0 = MO.tol.DTRtree(Ys = Ys1, w = w1.3, A = Trt1, H = Cov1,
                              delta = 0, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.01, minsplit = 15,
                              PO.loss = PO.loss.comp)
knitr::kable(tree1_MOtol3.0$tree, digits = 2)
# When delta = 0.4 (allow some of the treatments) -->  KA/VE and CVD is the tolerant treatment at stage 2
tree1_MOtol3.4 = MO.tol.DTRtree(Ys = Ys1, w = w1.3, A = Trt1, H = Cov1,
                              delta = 0.3, tolerate = TRUE, m.method="AIPW", 
                              depth = 3, lambda.pct = 0.01, minsplit = 15, 
                              PO.loss = PO.loss.comp)
knitr::kable(tree1_MOtol3.4$tree, digits = 2)
```

